---
description: 
globs: 
alwaysApply: true
---
---
description: Apply this rule when working with ASP.NET Core MVC or Razor Pages within an ABP Framework project. This includes creating/modifying pages (.cshtml) and their models (.cs), handling model binding/validation, using partial views, and especially leveraging ABP UI Tag Helpers like abp-dynamic-form and the theming system.
globs: **/*.cshtml, **/*.cs
alwaysApply: true
---

# MVC / Razor Pages Best Practices (ABP)

## Critical Rules

- **Razor Pages:** Prefer Razor Pages for server-side rendered UI scenarios in ABP.
- **Model Binding & Validation:** Utilize ASP.NET Core's model binding (`[BindProperty]`) and data annotations/FluentValidation for robust input validation.
- **ABP Tag Helpers:** Heavily favor ABP Tag Helpers for UI generation. **Use `<abp-dynamic-form>`** for forms based on a ViewModel/DTO to automatically generate fields based on model properties and attributes, reducing boilerplate HTML. Use other helpers like `<abp-modal>`, `<abp-card>`, `<abp-table>` etc.
- **Partial Views:** Use partial views (`_PartialName.cshtml`) for reusable UI components.
- **ABP Theming:** Leverage ABP's theming system (e.g., LeptonX) for consistent styling and layout. Avoid excessive custom CSS when the theme provides components.
- **ViewModel/DTO:** Use dedicated ViewModels or DTOs for your pages/views, decorated with necessary Data Annotations (`[Required]`, `[StringLength]`, `[Display]`, etc.) to drive both validation and the display logic of `<abp-dynamic-form>`.

## Examples

<example>
  // Assuming: using Microsoft.AspNetCore.Mvc;
  // Assuming: using Microsoft.AspNetCore.Mvc.RazorPages;
  // Assuming: using System.ComponentModel.DataAnnotations;
  // Assuming: using System.Threading.Tasks;
  // Assuming: using Volo.Abp.AspNetCore.Mvc.UI.RazorPages; // For AbpPageModel
  // Assuming: using System.ComponentModel; // For DisplayName

  // In MyProject.Web/Pages/Products/CreateModal.cshtml.cs
  public class CreateModalModel : AbpPageModel 
  {
      [BindProperty] 
      public ProductCreateViewModel Input { get; set; }

      private readonly IProductAppService _productAppService; 

      public CreateModalModel(IProductAppService productAppService)
      {
          _productAppService = productAppService;
      }

      public void OnGet() 
      {
          Input = new ProductCreateViewModel(); 
      }

      public async Task<IActionResult> OnPostAsync()
      {
          // Validation automatically handled based on ViewModel annotations
          var dto = ObjectMapper.Map<ProductCreateViewModel, CreateUpdateProductDto>(Input);
          await _productAppService.CreateAsync(dto);
          return NoContent(); 
      }

      // ViewModel driving the dynamic form
      public class ProductCreateViewModel
      {
          [Required]
          [StringLength(100, MinimumLength = 3)]
          [Display(Name = "Product Name")] // Used by abp-dynamic-form for label
          public string Name { get; set; }

          [Required]
          [Range(0.01, 10000.00)]
          [DataType(DataType.Currency)] // Hint for input type
          public decimal Price { get; set; }
          
          [DisplayName("In Stock?")] // Alternative to Display(Name=...)
          public bool IsAvailable { get; set; }
      }
  }

  // In MyProject.Web/Pages/Products/CreateModal.cshtml
  /*
  @page
  @model MyProject.Web.Pages.Products.CreateModalModel
  @using Volo.Abp.AspNetCore.Mvc.UI.Bootstrap.TagHelpers.Modal
  @using Volo.Abp.AspNetCore.Mvc.UI.Bootstrap.TagHelpers.Form // Namespace for abp-dynamic-form
  @{ Layout = null; } 
  @* Use abp-dynamic-form bound to the Input ViewModel *@
  <abp-dynamic-form abp-model="Input" asp-page="/Products/CreateModal"> @* asp-page specifies the handler *@
    <abp-modal>
        <abp-modal-header title="Create Product"></abp-modal-header>
        <abp-modal-body>          
                <abp-form-content />
                @* Inputs for Name, Price, IsAvailable are generated automatically *@          
        </abp-modal-body>
        @* Modal footer typically generated by abp-dynamic-form, or can be added manually if needed *@
        <abp-modal-footer buttons="Save | Cancel" data-busy-text="Saving..."></abp-modal-footer> 
    </abp-modal>
  </abp-dynamic-form>
  */
</example>

<example type="invalid">
  // In MyBadPage.cshtml.cs
  public class MyBadPageModel : PageModel // Not using AbpPageModel
  {
      // Manual fetching of form values instead of model binding
      // Direct DbContext injection (violates architecture)
      // Manual validation logic
      // ... (Code omitted for brevity - see previous example) ...
  }

  // In MyBadPage.cshtml
  /*
  // Not using abp-dynamic-form, requires manual creation of labels, inputs, validation messages
  <form method="post">
      <div class="form-group">
          <label for="productName">Product Name:</label> @* Manual label *@
          <input type="text" id="productName" name="productName" class="form-control" /> @* Manual input *@
          <span class="text-danger field-validation-valid" data-valmsg-for="productName" data-valmsg-replace="true"></span> @* Manual validation message span *@
      </div>
      <div class="form-group">
           <label for="productPrice">Price:</label>
           <input type="number" step="0.01" id="productPrice" name="productPrice" class="form-control" /> 
           <span class="text-danger field-validation-valid" data-valmsg-for="productPrice" data-valmsg-replace="true"></span>
      </div>
       <div class="form-group form-check">
           <input type="checkbox" id="isAvailable" name="isAvailable" value="true" class="form-check-input" /> 
           <label class="form-check-label" for="isAvailable">In Stock?</label>
      </div>
      <button type="submit" class="btn btn-primary">Save</button> @* Manual button *@
  </form>
  // This approach is verbose, error-prone, and doesn't leverage ABP's UI helpers for consistency and efficiency.
  */
</example>
